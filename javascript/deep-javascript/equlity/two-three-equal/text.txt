ğ‰ğšğ¯ğšğ’ğœğ«ğ¢ğ©ğ­ â€” `==` ğ¯ğ¬ `===` (ğ“ğ¡ğ ğ«ğğšğ¥ ğğ¢ğ¬ğœğ®ğ¬ğ¬ğ¢ğ¨ğ§)

â€¢ The debate is NOT â€œdouble equals is badâ€
The real question is: do you understand the types involved?

â€¢ `===` avoids coercion
It protects you when you **donâ€™t know or canâ€™t trust the types**

â€¢ `==` allows coercion
It can be **intentional, safe, and expressive** when types are understood

â€¢ Your choice of `===` is often a trailing indicator
It signals uncertainty about the types in the comparison

â€¢ The real problem is not the operator
The real problem is **unknown or unclear types**

â€¢ Fixing the root cause (making types obvious)
Leads to better code, fewer bugs, and clearer intent
Regardless of which operator you use

â€¢ A powerful and practical use of `==`
`null == undefined` â†’ true
These two values are coercively equal **only to each other**

â€¢ This allows a single â€œempty checkâ€
Treats null and undefined as the same absence of value
Which is often more readable and intentional

â€¢ Writing multiple strict checks can hurt clarity
Explicit does not always mean clearer
Sometimes it just adds cognitive load

â€¢ Even strong critics of coercion use:
`value == null`
Because itâ€™s predictable, safe, and expressive

â€¢ Linters are opinions, not truth
Use rules that help your team write better code
Disable rules that block valid, intentional patterns

ğ‘ğ®ğ¥ğ:
ğŸ‘‰ Donâ€™t choose `===` by habit
ğŸ‘‰ Choose based on **what you know about the types**
ğŸ‘‰ If types are unclear, fix that first

Inspired by Kyle Simpson (You Donâ€™t Know JS)

**Follow for more JavaScript internals and real-world nuance.**

#JavaScript #Coercion #Equality #CleanCode #Frontend #YouDontKnowJS
