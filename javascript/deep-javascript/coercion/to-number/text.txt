ğ€ğ›ğ¬ğ­ğ«ğšğœğ­ ğğ©ğğ«ğšğ­ğ¢ğ¨ğ§ğ¬ ğ¢ğ§ ğ‰ğšğ¯ğšğ’ğœğ«ğ¢ğ©ğ­ â€” ğ“ğ¨ğğ®ğ¦ğ›ğğ« ğğ±ğ©ğ¥ğšğ¢ğ§ğğ

â€¢ ToNumber runs whenever JavaScript needs a numeric value
  - Math operations, comparisons, arithmetic, etc.

â€¢ Strings â†’ numbers (mostly sensible)
  - "0" â†’ 0
  - "-0" â†’ -0
  - "009" â†’ 9
  - "3.14159" â†’ 3.14159
  - "0xaf" â†’ 175 (hex)

â€¢ Empty string is the real troublemaker
  - "" â†’ 0
  - This is the root of many coercion bugs

â€¢ Some strings still fail
  - "." â†’ NaN
  - Non-numeric strings â†’ NaN

â€¢ Booleans â†’ numbers
  - false â†’ 0
  - true â†’ 1
  - (historical decision, but debatable)

â€¢ null vs undefined
  - null â†’ 0
  - undefined â†’ NaN
  - (inconsistent, but real)

â€¢ Non-primitives trigger ToPrimitive first
  - ToNumber â†’ ToPrimitive (number hint)

â€¢ Objects & arrays
  - valueOf usually returns the object itself
  - JavaScript then falls back to toString

â€¢ Arrays become strings first
  - [] â†’ "" â†’ 0
  - [0] â†’ "0" â†’ 0
  - [null] â†’ "" â†’ 0
  - [undefined] â†’ "" â†’ 0
  - [1,2] â†’ "1,2" â†’ NaN

â€¢ Objects usually become NaN
  - "[object Object]" is not a valid number

â€¢ valueOf can override everything
  - If valueOf returns a primitive number, thatâ€™s the result

ğ‘ğ®ğ¥ğ:
ğŸ‘‰ ğ“ğ¨ğğ®ğ¦ğ›ğğ« = ğ“ğ¨ğğ«ğ¢ğ¦ğ¢ğ­ğ¢ğ¯ğ â†’ ğ¯ğšğ¥ğ®ğğğŸ â†’ ğ­ğ¨ğ’ğ­ğ«ğ¢ğ§ğ  â†’ ğğ®ğ¦ğ›ğğ«
ğŸ‘‰ ğˆğŸ ğ¬ğ¨ğ¦ğğ­ğ¡ğ¢ğ§ğ  ğ®ğ§ğğ±ğ©ğğœğ­ğğğ¥ğ² ğ›ğğœğ¨ğ¦ğğ¬ ğŸ ğ¨ğ« ğğšğ, ğœğ¨ğğ«ğœğ¢ğ¨ğ§ ğ¢ğ¬ ğ¢ğ§ğ¯ğ¨ğ¥ğ¯ğğ.

Follow for more JavaScript internals and edge cases.

#JavaScript #Coercion #ToNumber #CleanCode #Frontend #YouDontKnowJS