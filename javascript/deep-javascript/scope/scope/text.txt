ğ’ğœğ¨ğ©ğ ğ¢ğ§ ğ‰ğšğ¯ğšğ’ğœğ«ğ¢ğ©ğ­ â€” ğ‹ğğ±ğ¢ğœğšğ¥ ğ’ğœğ¨ğ©ğ ğğ±ğ©ğ¥ğšğ¢ğ§ğğ

â€¢ Scope answers one simple question
**Where do we look for things?**

â€¢ What are we looking for?
**Identifiers** (variables, functions, parameters)

â€¢ Every identifier plays only one of two roles
â€“ Receiving a value (assignment)
â€“ Retrieving a value (lookup)

â€¢ JavaScript uses **lexical scope**
Scope is determined by **where code is written**, not how itâ€™s executed

â€¢ Scopes are like **buckets**
Identifiers are **marbles**
The engine sorts marbles into buckets based on where they appear in the code

â€¢ This sorting does **not** happen at runtime
It happens **before execution**

â€¢ JavaScript is not just â€œline-by-line interpretedâ€
It is **parsed and compiled first**

â€¢ Proof JavaScript is compiled
A syntax error on line 10 stops lines 1â€“9 from running
Thatâ€™s impossible without a prior processing step

â€¢ During compilation, JavaScript:
â€“ Lexes and parses the code
â€“ Builds an Abstract Syntax Tree
â€“ Plans the **lexical environment** (all scopes + identifiers)

â€¢ Execution happens only **after** scopes are prepared

â€¢ JavaScript is a **two-pass system**

1. Compile (create scopes, place identifiers)
2. Execute (run the code)

â€¢ Scope â€œbucketsâ€ come from:
â€“ Functions
â€“ Blocks (since ES6)

â€¢ These buckets define **where identifiers belong**
And where lookups are allowed to happen

â€¢ Understanding lexical scope is foundational
â€“ Scope â†’ enables Closure
â€“ Closure â†’ enables Modules
â€“ Modules â†’ enable scalable architecture

ğ‘ğ®ğ¥ğ:
ğŸ‘‰ Think like the JavaScript engine
ğŸ‘‰ Scopes are decided **before** your code runs

Inspired by Kyle Simpson (You Donâ€™t Know JS)

**Follow for more JavaScript internals, scope, and closure deep dives.**

#JavaScript #Scope #LexicalScope #CleanCode #Frontend #YouDontKnowJS
