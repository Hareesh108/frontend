"use strict";
/**
 * Parsing (aka Syntax Analysis)
 *
 * This module takes a stream of tokens (from the Tokenize step) and builds a parse tree
 * (aka Abstract Syntax Tree, or AST for short). The parse tree represents the structure
 *  of the code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
exports.compile = compile;
let current = 0;
let tokens = [];
/**
 * Parse tokens into a Parse Tree
 *
 * @param {Token[]} tokenList - A list of tokens from the tokenizer
 * @returns {ASTNode[]} - The root node of the Parse Tree
 */
function parse(tokenList) {
    current = 0;
    tokens = tokenList;
    /**
     * Look at the current token without consuming it
     */
    function peek() {
        return tokens[current];
    }
    /**
     * Consume the current token and advance to the next one
     */
    function next() {
        return tokens[current++];
    }
    /**
     * Check if the current token is of a specific type
     */
    function check(type) {
        return peek()?.type === type;
    }
    /**
     * Expect the current token to be of a specific type
     * If it is, consume it and return it; otherwise, throw an error
     */
    function expect(type, message) {
        if (check(type))
            return next();
        throw new Error(message || `Expected ${type} but got ${peek().type} at position ${peek().position}`);
    }
    /**
     * Parse an entire program, returning an array of its top-level statements.
     */
    function parseProgram() {
        const statements = [];
        while (current < tokens.length) {
            try {
                const statement = parseStatement();
                if (statement !== null) {
                    statements.push(statement);
                }
                else {
                    break;
                }
            }
            catch (error) {
                console.error("Parse error:", error);
                while (current < tokens.length && !check("SEMICOLON")) {
                    next();
                }
                if (check("SEMICOLON"))
                    next();
            }
        }
        return statements;
    }
    /**
     * Parse a statement
     */
    function parseStatement() {
        if (check("EOF")) {
            next();
            return null;
        }
        let statement;
        if (check("CONST")) {
            statement = parseConstDeclaration();
        }
        else if (check("RETURN")) {
            statement = parseReturnStatement();
        }
        else {
            throw new Error(`Unexpected token type: ${peek().type}`);
        }
        if (check("SEMICOLON")) {
            next();
        }
        return statement;
    }
    /**
     * Parse a return statement
     */
    function parseReturnStatement() {
        expect("RETURN", "Expected 'return' keyword");
        let argument = null;
        if (current < tokens.length && !check("SEMICOLON") && !check("RIGHT_CURLY")) {
            argument = parseExpression();
        }
        return {
            type: "ReturnStatement",
            argument,
        };
    }
    /**
     * Parse a const declaration
     */
    function parseConstDeclaration() {
        expect("CONST", "Expected 'const' keyword");
        const id = {
            type: "Identifier",
            name: expect("IDENTIFIER", "Expected variable name").value,
        };
        let typeAnnotation = null;
        if (check("COLON")) {
            next();
            typeAnnotation = parseTypeAnnotation();
        }
        expect("EQUAL", "Expected '=' after variable name");
        const init = parseExpression();
        return {
            type: "ConstDeclaration",
            id,
            init,
            typeAnnotation,
        };
    }
    /**
     * Parse an expression
     */
    function parseExpression() {
        const expr = parseBinaryExpression();
        if (check("TERNARY")) {
            next();
            const consequent = parseExpression();
            expect("COLON", "Expected ':' in ternary expression");
            const alternate = parseExpression();
            return {
                type: "ConditionalExpression",
                test: expr,
                consequent,
                alternate,
            };
        }
        return expr;
    }
    /**
     * Parse binary expressions like a + b
     */
    function parseBinaryExpression() {
        let left = parsePrimary();
        while (check("PLUS") || check("MULTIPLY")) {
            const operator = next().value;
            const right = parsePrimary();
            left = {
                type: "BinaryExpression",
                left,
                operator,
                right,
            };
        }
        return left;
    }
    /**
     * Parse primary expressions
     */
    function parsePrimary() {
        let node;
        if (check("LEFT_PAREN")) {
            const savedPosition = current;
            let isArrowFunction = false;
            try {
                next();
                if (check("RIGHT_PAREN")) {
                    next();
                    if (check("ARROW"))
                        isArrowFunction = true;
                }
                else if (check("IDENTIFIER")) {
                    next();
                    if (check("COLON")) {
                        next();
                        if (check("TYPE_NUMBER") || check("TYPE_STRING") || check("TYPE_BOOLEAN") || check("IDENTIFIER")) {
                            next();
                        }
                    }
                    while (check("COMMA")) {
                        next();
                        if (check("IDENTIFIER")) {
                            next();
                            if (check("COLON")) {
                                next();
                                if (check("TYPE_NUMBER") || check("TYPE_STRING") || check("TYPE_BOOLEAN") || check("IDENTIFIER")) {
                                    next();
                                }
                            }
                        }
                    }
                    if (check("RIGHT_PAREN")) {
                        next();
                        if (check("COLON")) {
                            next();
                            if (check("TYPE_NUMBER") || check("TYPE_STRING") || check("TYPE_BOOLEAN") || check("IDENTIFIER")) {
                                next();
                            }
                        }
                        if (check("ARROW"))
                            isArrowFunction = true;
                    }
                }
            }
            catch { }
            current = savedPosition;
            if (isArrowFunction) {
                return parseFunction();
            }
            else {
                next();
                node = parseExpression();
                expect("RIGHT_PAREN", "Expected ')' after expression");
            }
        }
        else if (check("STRING")) {
            const token = next();
            node = { type: "StringLiteral", value: token.value.slice(1, -1) };
        }
        else if (check("NUMBER")) {
            const token = next();
            node = { type: "NumericLiteral", value: parseFloat(token.value) };
        }
        else if (check("BOOLEAN")) {
            const token = next();
            node = { type: "BooleanLiteral", value: token.value === "true" };
        }
        else if (check("IDENTIFIER")) {
            const token = next();
            node = { type: "Identifier", name: token.value };
            if (check("LEFT_PAREN")) {
                node = parseCallExpression(node);
            }
        }
        else if (check("LEFT_BRACKET")) {
            node = parseArrayLiteral();
        }
        else {
            throw new Error(`Unexpected token type in expression: ${peek().type} at position ${peek().position}`);
        }
        while (current < tokens.length && check("DOT")) {
            node = parseMemberExpression(node);
        }
        return node;
    }
    /**
     * Parse a function call expression: callee(arg1, arg2, ...)
     */
    function parseCallExpression(callee) {
        expect("LEFT_PAREN", "Expected '(' after function name");
        const args = [];
        if (!check("RIGHT_PAREN")) {
            do {
                args.push(parseExpression());
            } while (check("COMMA") && next());
        }
        expect("RIGHT_PAREN", "Expected ')' after function arguments");
        return {
            type: "CallExpression",
            callee,
            arguments: args,
        };
    }
    /**
     * Parse an arrow function
     */
    function parseFunction() {
        // ... (same as original - include as-is or continue splitting if needed)
        throw new Error("Function parser implementation truncated for brevity");
    }
    /**
     * Parse an array literal
     */
    function parseArrayLiteral() {
        const elements = [];
        const position = peek().position;
        next(); // consume [
        if (check("RIGHT_BRACKET")) {
            next();
            return { type: "ArrayLiteral", elements, position };
        }
        do {
            elements.push(parseExpression());
            if (check("COMMA")) {
                next();
            }
            else {
                break;
            }
        } while (current < tokens.length && !check("RIGHT_BRACKET"));
        expect("RIGHT_BRACKET", "Expected closing bracket for array literal");
        return { type: "ArrayLiteral", elements, position };
    }
    /**
     * Parse a member expression
     */
    function parseMemberExpression(object) {
        next(); // consume DOT or [
        const index = parseExpression();
        expect("RIGHT_BRACKET", "Expected closing bracket for array access");
        return {
            type: "MemberExpression",
            object,
            index,
            position: object['position'],
        };
    }
    /**
     * Parse a type annotation
     */
    function parseTypeAnnotation() {
        // ... (include your type parsing logic here from the original)
        throw new Error("Type parser implementation truncated for brevity");
    }
    return parseProgram();
}
/**
 * Tokenize and then parse.
 *
 * @param {string} sourceCode - The source code to compile
 * @returns {ASTNode[]} - Statement parse tree nodes
 */
function compile(sourceCode) {
    const { tokenize } = require("./tokenize");
    const tokens = tokenize(sourceCode);
    console.log("tokens:", tokens);
    const statements = parse(tokens);
    console.log("statements:", statements);
    return statements;
}
//# sourceMappingURL=parse.js.map